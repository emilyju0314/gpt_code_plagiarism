tcu::TestNode::IterateResult SpirvModulesErrorVerificationTest::iterate()
{
	const Functions& gl = m_context.getRenderContext().getFunctions();

	const char* shaderSrc = m_vertex.c_str();
	const int   shaderLen = m_vertex.length();

	ShaderBinary vertexBinary;

#if defined DEQP_HAVE_GLSLANG
	vertexBinary = spirvUtils::makeSpirV(m_context.getTestContext().getLog(), VertexSource(m_vertex));
#else  // DEQP_HAVE_GLSLANG
	tcu::Archive& archive = m_testCtx.getArchive();
	vertexBinary		  = commonUtils::readSpirV(archive.getResource("spirv/modules_error_verification/vertex.nspv"));
#endif // DEQP_HAVE_GLSLANG

	gl.shaderSource(m_glslShaderId, 1, &shaderSrc, &shaderLen);
	GLU_EXPECT_NO_ERROR(gl.getError(), "shaderSource");

	gl.shaderBinary(1, &m_spirvShaderId, GL_SHADER_BINARY_FORMAT_SPIR_V_ARB, (GLvoid*)vertexBinary.binary.data(),
					vertexBinary.binary.size() * sizeof(deUint32));
	GLU_EXPECT_NO_ERROR(gl.getError(), "shaderBinary");

	gl.attachShader(m_programId, m_spirvShaderId);
	GLU_EXPECT_NO_ERROR(gl.getError(), "attachShader");

	GLint err;

	// 1) Verify if CompileShader function used on shader with SPIR_V_BINARY_ARB state
	//    will result in generating INVALID_OPERATION error.
	gl.compileShader(m_spirvShaderId);
	err = gl.getError();
	if (err != GL_INVALID_OPERATION)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by CompileShader [1]. Expected INVALID_OPERATION, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 2) Verify if SpecializeShader function generate INVALID_VALUE error when
	//    <shader> is not the name of either a program or shader object.
	gl.specializeShader(0xFFFF, "main", 0, DE_NULL, DE_NULL);
	err = gl.getError();
	if (err != GL_INVALID_VALUE)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by SpecializeShader [2]. Expected INVALID_VALUE, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 3) Verify if SpecializeShader function generate INVALID_OPERATION error when
	//    <shader> is the name of a program object.
	gl.specializeShader(m_programId, "main", 0, DE_NULL, DE_NULL);
	err = gl.getError();
	if (err != GL_INVALID_OPERATION)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by SpecializeShader [3]. Expected INVALID_OPERATION, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 4) Verify if SpecializeShader function generate INVALID_OPERATION error when
	//    SPIR_V_BINARY_ARB state for <shader> is not TRUE.
	gl.specializeShader(m_glslShaderId, "main", 0, DE_NULL, DE_NULL);
	err = gl.getError();
	if (err != GL_INVALID_OPERATION)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by SpecializeShader [4]. Expected INVALID_OPERATION, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 5) Verify if SpecializeShader function generate INVALID_VALUE when <pEntryPoint>
	//    does not name a valid entry point for <shader>.
	gl.specializeShader(m_spirvShaderId, "entry", 0, DE_NULL, DE_NULL);
	err = gl.getError();
	if (err != GL_INVALID_VALUE)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by SpecializeShader [5]. Expected INVALID_VALUE, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 6) Verify if SpecializeShader function generate INVALID_VALUE when any element
	//    of <pConstantIndex> refers to a specialization constant that does not exist
	//    in the shader module contained in <shader>.
	const GLuint specID	= 10;
	const GLuint specValue = 10;
	gl.specializeShader(m_spirvShaderId, "main", 1, &specID, &specValue);
	err = gl.getError();
	if (err != GL_INVALID_VALUE)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by SpecializeShader [6]. Expected INVALID_VALUE, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 7) Verify if LinkProgram fail when one or more of the shader objects attached to
	//    <program> are not specialized.
	gl.linkProgram(m_programId);
	err = gl.getError();
	if (err == GL_NO_ERROR)
	{
		GLint linkStatus;
		gl.getProgramiv(m_programId, GL_LINK_STATUS, &linkStatus);
		GLU_EXPECT_NO_ERROR(gl.getError(), "getProgramiv");

		if (linkStatus != 0)
		{
			m_testCtx.getLog() << tcu::TestLog::Message << "Unexpected result of LinkProgram [7]."
							   << tcu::TestLog::EndMessage;

			m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
			return STOP;
		}
	}

	// 8) Verify if SpecializeShader function generate INVALID_OPERATION error if the
	//    shader has already been specialized.
	gl.specializeShader(m_spirvShaderId, "main", 0, DE_NULL, DE_NULL);
	GLU_EXPECT_NO_ERROR(gl.getError(), "specializeShader");

	gl.specializeShader(m_spirvShaderId, "main", 0, DE_NULL, DE_NULL);
	err = gl.getError();
	if (err != GL_INVALID_OPERATION)
	{
		m_testCtx.getLog()
			<< tcu::TestLog::Message
			<< "Unexpected error code generated by SpecializeShader [8]. Expected INVALID_OPERATION, generated: "
			<< glu::getErrorName(err) << tcu::TestLog::EndMessage;

		m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
		return STOP;
	}

	// 9) Verify if LinkProgram fail when not all of shaders attached to <program> have
	//    the same value for the SPIR_V_BINARY_ARB state.
	gl.compileShader(m_glslShaderId);
	GLU_EXPECT_NO_ERROR(gl.getError(), "compileShader");

	gl.attachShader(m_programId, m_glslShaderId);
	GLU_EXPECT_NO_ERROR(gl.getError(), "attachShader");

	gl.linkProgram(m_programId);
	err = gl.getError();
	if (err == GL_NO_ERROR)
	{
		GLint linkStatus;
		gl.getProgramiv(m_programId, GL_LINK_STATUS, &linkStatus);
		GLU_EXPECT_NO_ERROR(gl.getError(), "getProgramiv");

		if (linkStatus != 0)
		{
			m_testCtx.getLog() << tcu::TestLog::Message << "Unexpected result of LinkProgram [9]."
							   << tcu::TestLog::EndMessage;

			m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Fail");
			return STOP;
		}
	}

	m_testCtx.setTestResult(QP_TEST_RESULT_PASS, "Pass");
	return STOP;
}