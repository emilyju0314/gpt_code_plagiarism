/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author aajisaka
 */


#include<bits/stdc++.h>

using namespace std;

void debug_out() { cerr << endl; }
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
  cerr << " " << to_string(H);
  debug_out(T...);
}
#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)
#define rep(i,n) for(int i=0; i<(int)(n); i++)
#define all(v) v.begin(), v.end()
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }

using ll = long long;
using ull = unsigned long long;
using P = pair<ll, ll>;

constexpr long double PI = 3.14159265358979323846264338327950288L;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

class DKeepDistances {
public:
    void solve(istream& cin, ostream& cout) {
      SPEED;
      int n, k; cin >> n >> k;
      vector<int> x(n);
      rep(i, n) {
        cin >> x[i];
      }

      vector<vector<int>> next(20, vector<int>(n, n));
      vector<vector<ll>> dp(20, vector<ll>(n, 0));
      int j=1;
      for(int i=0; i<n; i++) {
        while(j < n && x[j] - x[i] < k) {
          j++;
        }
        next[0][i] = j;
        dp[0][i] = j;
      }

      vector<vector<int>> next2(20, vector<int>(n, -1));
      vector<vector<ll>> dp2(20, vector<ll>(n, 0));
      j=n-2;
      for(int i=n-1; i>=0; i--) {
        while(j >= 0 && x[i] - x[j] < k) {
          j--;
        }
        next2[0][i] = j;
        dp2[0][i] = j;
      }

      for(int r=1; r<20; r++) {
        for(int i=0; i<n; i++) {
          if (next[r-1][i] == n) {
            next[r][i] = n;
          } else {
            next[r][i] = next[r-1][next[r-1][i]];
            dp[r][i] = dp[r-1][i] + dp[r-1][next[r-1][i]];
          }
        }
      }

      for(int r=1; r<20; r++) {
        for(int i=0; i<n; i++) {
          if (next2[r-1][i] == -1) {
            next2[r][i] = -1;
          } else {
            next2[r][i] = next2[r-1][next2[r-1][i]];
            dp2[r][i] = dp2[r-1][i] + dp2[r-1][next2[r-1][i]];
          }
        }
      }

      int q; cin >> q;
      rep(_, q) {
        int l, r; cin >> l >> r;
        l--; r--;
        ll lcnt = l;
        int now = l;
        int cnt = 1;
        for(int p=19; p>=0; p--) {
          if (next[p][now] <= r) {
            lcnt += dp[p][now];
            now = next[p][now];
            cnt += (1<<p);
          }
        }
        //debug(_, lcnt);
        now = r;
        ll rcnt = r;
        for(int p=19; p>=0; p--) {
          if (next2[p][now] >= l) {
            rcnt += dp2[p][now];
            now = next2[p][now];
          }
        }
        //debug(_, rcnt);
        cout << rcnt-lcnt+cnt << '\n';
      }
    }
};

signed main() {
  DKeepDistances solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}